힙 정렬 : 힙 트리구조를 이용하는 정렬방법

이진트리 : 컴퓨터에서 데이터를 표현할때 데이터를 각 노드에 담은 뒤. 노드를 두개씩 이어붙이는 구조.
        모든 노드의 자식노드가 2개 이하인 구조. (*트리 : 가지를 뻗어나가는 것처럼 데이터가 서로 연결됨)
완전이진트리 : 데이터가 루트 노드로부터 시작하여 자식노드가 왼,오른쪽 자식노드로 차근차근 들어가는 구조의 이진트리. (이진트리의 노드가 중간에 비지않고 빽빽함.)

힙(heap) : 최소,최댓값을 빠르게 찾아내기 위해 이진트리를 기반으로 하는 트리. 최대힙 - '부모노드'>'자식노드'인 힙

but. 트리안에서 특정노드때문에 최대힙이 붕괴되는 경우가 존재함 그래서...

힙 생성 알고리즘
- 특정 노드의 두 자식 중 더 큰 자식과 자신의 위치를 바꾸는 알고리즘
-'하나의 노드를 제외하고는 최대힙이 구성되어 있는 상태'로 가정
-특정한 '하나의 노드'에 대해 수행
-위치를 바꾼 후에도 여전히 자식이 존재하는 경우 또 자식중에서 더 큰 자식과 자신의 위치를 바꿔야 함.

-힙 생성 알고리즘의 시간 복잡도 : O(logN) : 한번 내려갈때마다 노드의 갯수가 2배씩 증가하기 때문

풀이과정) 데이터를 배열에 넣고, 트리로 표현한뒤, 힙생성 알고리즘을 적용시킨다.

#include <stdio.h>

int number = 9;
int heap[9]={7,6,5,8,3,5,9,1,6};

int main(void){
  for(int i=1; i<number; i++){// 전체 트리구조를 최대 힙 구조로 바꾸기
    int c=i; //자식의 값
    do{
      int root= (c-1)/2; // 특정한 원소(자식)의 부모
      if(heap[root] < heap[c]){ // 부모크기 < 자식크기 일때 서로 위치를 바꿈
          int temp = heap[root];
          heap[root] = heap[c];
          heap[c] = temp;
      }
      c = root; //자식이 부모의 위치로 이동하여 반복(위로 계속 올라가는 식)
    } while(c!=0);
  }//for문 끝
  
  
  
  //전체 트리구조가 최대 힙 구조인 상태
  for(int i=number-1; i>=0; i--){// 크기를 줄여가며 반복적으로 힙 구성
    int temp= heap[0]; 
    heap[0] = heap[i];
    heap[i] = temp; 
    // 맨 뒤 값 heap[i]와 현재 가장 큰 값인 루트 heap[0]의 값의 위치를 바꿔줌으로써 가장 큰 값이 뒤로 가게 한다.(오름차순 정렬)
    int root=0;
    int c=1;
    
    do{
      c = 1 * root +1; // 자식 중에 더 큰 값 찾기
      if(c < i-1 && heap[c]<heap[c+1]){
        c++;
      }
      if(c<i && heap[root]<heap[c]){
        temp = heap[root];
        heap[root]=heap[c];
        heap[c]=temp;
      }
      root=c;
   } while(c<i);
}
  
  for(int i=0; i<number; i++){
    printf("&d", heap[i]);
  }
}

Q)
10 26 5 37 1 61 11 59 15 48 19
위와 같이 열개의 원소가 들어왔을때 다음과 같은 정렬과정이 출력되도록 하는 프로그램을 작성하되,
이때 힙 생성을 함에 있어서 하향식으로 구현하시오.

<예시입력>
10
10 26 5 37 1 61 11 59 15 48 19


<예시출력>

61 48 59 26 19 11 37 15 1 5
59 48 37 26 19 11 6 16 1 61
48 26 37 15 19 11 5 1 59 61
37 26 11 15 19 1 5 48 59 61
26 19 11 15 5 1 37 48 59 61
19 15 11 1 5 26 37 28 59 61
15  5 11 1 19 26 37 48 59 61
11 5 1 15 19 26 37 48 59 61
5 1 11 15 19 26 37 48 59 61
1 5 11 15 19 26 37 48 59 61

풀이)





