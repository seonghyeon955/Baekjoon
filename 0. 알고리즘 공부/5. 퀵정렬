퀵정렬 - 대표적인 '분할정복' 알고리즘으로 평균속도는 O(N*logN)이다.
하나의 큰 문제를 두개의 작은 문제로 분할하는 식으로 빠르게 정렬, 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤 배열을 반으로 나눈다.
*특정한 수 = 피벗값. 기준이 되는 값으로 보통 첫번째 원소를 선정한다.

ex)

3 7 8 1 5 9 6 10 2 4

'3'을 기준으로 왼->오 이동시 3보다 큰 수 : 7 
            오->왼 이동시 3보다 작은 수 : 2 
바꿈

3 2 8 1 5 9 6 10 7 4
'3'을 기준으로 왼->오 이동시 3보다 큰 수 : 8 
            오->왼 이동시 3보다 작은 수 : 1
바꿈

3 2 1 8 5 9 6 10 7 4
'3'을 기준으로 왼->오 이동시 3보다 큰 수 : 8 
            오->왼 이동시 3보다 작은 수 : 1 --> 동일한 경우 '엇갈린 상황' 이라 칭함
            *엇갈린 상황 : 작은값의 인덱스가 큰값의 인덱스를 앞지름(작은값의 인덱스 < 큰값의 인덱스) -> 왼쪽의 작은값과 피벗값을 바꿔준다.
       

1 2 '3' 8 5 9 6 10 7 4
'3'을 기준으로 왼편은 3보다 작은수로, 오른편은 3보다 큰 수들로 정렬이 이루어졌다.
각 분할의 가장 앞에 있는 값인 1과 8을 피벗값으로 잡고 다시 정렬을 시작

'1'을 기준으로 왼->오 이동시 1보다 큰 수 : 2
            오->왼 이동시 1보다 작은 수 : 없으므로 자기자신 1.-> 엇갈린 상황. 피벗값은 2로 넘어간다.
'8'을 기준으로 왼->오 이동시 8보다 큰 수 : 9
            오->왼 이동시 8보다 작은 수 : 4
바꿈

1 2 3 8 5 4 6 10 7 9
'8'을 기준으로 왼->오 이동시 8보다 큰 수 : 10
            오->왼 이동시 8보다 작은 수 : 7
바꿈


1 2 3 8 5 4 6 7 10 9
'8'을 기준으로 왼->오 이동시 8보다 큰 수 : 10
            오->왼 이동시 8보다 작은 수 : 7 --> 위와 동일(엇갈린 상황) -> 왼쪽의 작은값(7)과 피벗값(8)을 바꾼다


1 2 3 7 5 4 6 8 10 9
'8'을 기준으로 왼쪽은 8보다 작은수, 오른쪽은 8보다 큰 수로 정렬 성공

'1' '2' '3' 7 5 4 6 '8' 10 9
피벗값이였던 값들을 제외하고 가장 왼편에 있는 수인 7과 10을 피벗값으로 잡는다.
'7'을 기준으로 왼->오 이동시 7보다 큰 수 : 없음(8,10은 피벗값이여서 제외) -> 피벗값(7)을 대신하여 6과 바꾼다.
            오->왼 이동시 7보다 작은수 : 6

바꾼 후 배열
'1' '2' '3' 6 5 4 '7' '8' 10 9
'7'을 기준으로 왼쪽은 7보다 작은 수, 오른쪽은 7보다 큰 수로 정렬 성공

'10'을 기준으로 왼->오 이동시 10보다 큰 수 : 없으므로 본인.
             오->왼 이동시 10보다 작은수 : 9
 바꿈
 '1' '2' '3' 6 5 4 '7' '8' 9 '10'
 
 '10'을 기준으로 왼쪽은 10보다 작은 수, 오른쪽은 10보다 큰 수로 정렬 성공
 다음 피벗값 : 6과 9
 
 '6'을 기준으로 왼->오 이동시 6보다 큰 수: 없으므로 본인
             오->왼 이동시 6보다 작은수 : 4
 바꿈
 '1' '2' '3'  4  5  6 '7' '8' 9 '10' 끝!
 
 
 
 
 퀵정렬이 빠른 이유
 : 1 2 3 4 5 6 7 8 9 10 일때
 N^2 = 10 * 10 = 100
 
 But 분할시엔 
 1 2 3 4 5 -> 5*5=25
 6 7 8 9 10  -> 5*5=25
 
 25+25=50으로 가짓수가 확 줄어들음
 O(N * logN)
 -N = 데이터 갯수
 -logN - 반씩쪼갬.
 
 
 
 [퀵정렬 코드 구현]
 
 
 
 


